#!/bin/bash
# By  : Automatic Generated by at.3.testcase.pl
# Date: Thu Feb 10 10:50:57 2011

# import local lib file
. ./lib.ipacert.sh

ipacert()
{
    cert_remove_hold
    cert_request
    cert_revoke
    cert_show
    cert_status
    cert_BZ
} #cert

#############################################
#  test suite: cert-remove-hold (3 test cases)
#############################################
cert_remove_hold()
{
    cert_remove_hold_envsetup
    cert_remove_hold_1001  #test_scenario (positive test): when cert revoked as reason 6 cert can remove hold
    cert_remove_hold_1002  #test_scenario (negative test): when cert revoked not as reason 6 cert cannot remove hold
    cert_remove_hold_1003  #test_scenario (negative test): when invalid cert id is given remove-hold should fail
    cert_remove_hold_1004  #test_scenario (negative test): Revoke a certificate which is not in revoked state 
    cert_remove_hold_envcleanup
} #cert-remove-hold

cert_remove_hold_envsetup()
{
    rlPhaseStartSetup "cert_remove_hold_envsetup"
        #environment setup starts here
        rlPass "no env setup here"
        #environment setup ends   here
    rlPhaseEnd
} #envsetup

cert_remove_hold_envcleanup()
{
    rlPhaseStartCleanup "cert_remove_hold_envcleanup"
        #environment cleanup starts here
        rlPass "no env cleanup here"
        #environment cleanup ends   here
    rlPhaseEnd
} #envcleanup
cert_remove_hold_1001()
{ #test_scenario (positive): --certid
    rlPhaseStartTest "cert_remove_hold_1001: when cert revoked as reason 6 cert can remove hold"
        local testID="cert_remove_hold_1001"
        local tmpout=$TmpDir/cert_remove_hold_1001.$RANDOM.out
        create_cert
        KinitAsAdmin
        for cert in `cat $certList`;do
        echo $cert
         local certid=`echo $cert | cut -d"=" -f2`
         echo $certid
         rlRun "ipa cert-revoke $certid --revocation-reason=6" 0 "set revoke reason to 6 -- this is only reason we can remove hold"
         ipa cert-show $certid > $tmpout
         reason=`grep -i "Revocation reason" $tmpout | cut -d":" -f2 | xargs echo`
         if [ "$reason" = "6" ];then
            rlLog "revoke reason set to [6] confirmed"
         else
            rlFail "revoke reason expected to be [6], actual [$reason], test can not continue"
            return
         fi
         rlRun "ipa cert-remove-hold $certid " 0 "test options: remove hold "

         #after remove hold, lets check the content again
         ipa cert-show $certid > $tmpout
         if grep -i "Revocation reason" $tmpout
         then
            rlFail "revocation reason still found in cert-show, test failed"
            cat $tmpout
         else
            rlPass "revocation reason not found in cert-show, test pass"
         fi
        done  
        Kcleanup
        rm $tmpout
    rlPhaseEnd
} #cert_remove_hold_1001

cert_remove_hold_1002()
{ #test_scenario (negative): when cert revoked in reason other than 6, remove-hold should fail
    rlPhaseStartTest "cert_remove_hold_1002: when cert revoked not as reason 6 cert cannot remove hold"
        local testID="cert_remove_hold_1002"
        local tmpout=$TmpDir/cert_remove_hold_1002.$RANDOM.out
        rlLog "iterating revokation reason from 0 -> 10 (skip 6) "
        # by rfc 5280, revokeCode = 7 is not being used
        for revokeCode in 0 1 2 3 4 5 6 8 9 10
        do
            rlLog "============= [revocation reason = $revokeCode ] ==============="
            create_cert
            local certid=`tail -n1 $certList | cut -d"=" -f2|cut -d" " -f1 | xargs echo`
            KinitAsAdmin
            rlRun "ipa cert-revoke $certid --revocation-reason=$revokeCode" 0 "set revoke reason to [$revokeCode], cert should not be able to reuse"
            ipa cert-show $certid > $tmpout
            reason=`grep -i "Revocation reason" $tmpout | cut -d":" -f2 | xargs echo`
            if [ "$reason" = "$revokeCode" ];then
                rlLog "revoke reason set to [$revokeCode] confirmed"
            else
                rlFail "revoke reason expected to be [$revokeCode], actual [$reason], test can not continue"
            fi
            rlRun "ipa cert-remove-hold $certid " 0 "cert-remove-hold always return 0(succes),we need more test to confirm remove hold fails" 

            #after remove hold, lets check the content again
		# Once the cert is removed from hold there exists no revocation reason in the certificate,
		# this caused beaker failure. Adding an "if" statement to exclude revocation code 6 to check
		# for revocation reason in the certificate. 
		if [ $revokeCode = 6 ]; then
			rlPass "revocation reason: $revokeCode, not found in cert-show, as expected"
		else
            		ipa cert-show $certid > $tmpout
		        if grep -i "Revocation reason: $revokeCode" $tmpout
		            then
	                	rlPass "revocation reason: $revokeCode, still found in cert-show, test pass"
		            else
                		rlFail "revocation reason: $revokeCode, not found in cert-show, test failed"
        		        cat $tmpout
		        fi
		fi
            Kcleanup
            rm $tmpout
        done
    rlPhaseEnd
} #cert_remove_hold_1002

cert_remove_hold_1003()
{ #test_scenario (negative):  remove-hold <invalid cert id>
    rlPhaseStartTest "cert_remove_hold_1003: remove-hold <invalid cert id>"
        local testID="cert_remove_hold_1003"
        local tmpout=$TmpDir/cert_remove_hold_1001.$RANDOM.out
        KinitAsAdmin
        # somehow ipa cert-remove-hold always report success regardless
        # I have to use output msg to determine the pass/fail 
        local certid="9999"
        local errmsg="Record not found"
        ipa cert-remove-hold $certid 2>&1 >$tmpout
        if grep -i "$errmsg" $tmpout 
        then
            rlPass "remove non-exist cert reports 'not found' error"
        else
            rlFail "no match error msg found"
            echo "====== expect ====================="
            echo $errmsg
            echo "====== actual ======================"
            cat $tmpout
            echo "===================================="
        fi

        local certid="abc"
        ipa cert-remove-hold $certid 2>&1 >$tmpout
        local errmsg="Record not found"
        if grep -i "$errmsg" $tmpout ;then
            rlPass "remove-hold an invalid cert failed as expected"
        else
            rlFail "remove-hold: error msg does not match, actual out as below"
            echo "======== expected =================="
            echo $errmsg
            echo "========= actual  =================="
            cat $tmpout
            echo "===================================="
        fi
        Kcleanup
    rlPhaseEnd
} #cert_remove_hold_1003
cert_remove_hold_1004()
{ #test_scenario (Negative): Unrevoke a certificate which is not revoked.
    rlPhaseStartTest "cert_remove_hold_1004: Unrevoke a certificate which is not revoked"
        local testID="cert_remove_hold_1004"
        local tmpout=$TmpDir/cert_remove_hold_1004.$RANDOM.out
        create_cert
        KinitAsAdmin
        for cert in `cat $certList`;do
        echo $cert
         local certid=`echo $cert | cut -d"=" -f2`
         echo $certid
         rlRun "ipa cert-remove-hold $certid " > $tmpout
         if grep -i "Error: One or more certificates could not be unrevoked" $tmpout
         then
            rlPass "ipa cert-remove-hold cannot unrevoke a certificate which is not in revoked state"
            cat $tmpout
         else
            rlFail "ipa cert-remove-hold unrevoked a certificate which is not in revoked state"
         fi
        done
        Kcleanup
        rm $tmpout
    rlPhaseEnd
} #cert_remove_hold_1004
#END OF TEST CASE for [cert-remove-hold]

#############################################
#  test suite: cert-request (9 test cases)
#############################################
cert_request()
{
    cert_request_envsetup
    cert_request_1001  #test_scenario (negative test): [--add --principal;negative;STR --request-type;positive;STR]
    cert_request_1002  #test_scenario (negative test): [--add --principal;positive;STR --request-type;negative;STR]
    cert_request_1003  #test_scenario (positive test): [--add --principal;positive;STR --request-type;positive;STR]
    cert_request_1004  #test_scenario (negative test): [--principal;negative;STR]
    cert_request_1005  #test_scenario (negative test): [--principal;negative;STR --request-type;positive;STR]
    cert_request_1006  #test_scenario (positive test): [--principal;positive;STR]
    cert_request_1007  #test_scenario (negative test): [--principal;positive;STR --request-type;negative;STR]
    cert_request_1008  #test_scenario (positive test): [--principal;positive;STR --request-type;positive;STR]
    cert_request_1009  #test_scenario (negative): use same cert request file and principle twice, the first will be revoked with reason 4
    cert_request_1010  #test_scenario (negative):csr given only as argument and service principal does not exists #Added by Kaleem
    cert_request_1011  #test_scenario (Positive):csr given only as argument after service principal added through ipa service-add #Added by Kaleem
    cert_request_1012  #test_scenario (negative): corrupted csr given as argument after service principal added through ipa service-add #Added by Kaleem
    cert_request_1013  #test_scenario (Positive):csr given only as argument along with --add option #Added by Kaleem
    cert_request_1014  #test_scenario (Positive):csr-positive, request-type --positive --add option #Added by Kaleem
    cert_request_1015  #test_scenario (Negative):csr-positive, request-type -- negative --add option #Added by Kaleem
    cert_request_1016  #test_scenario (Negative):csr-positive, principal - negative request-type -- negative --add option #Added by Kaleem
    cert_request_1017  #test_scenario (Negative):csr-positive, principal - negative request-type -- negative --add option #Added by Kaleem
    cert_request_envcleanup
} #cert-request

cert_request_envsetup()
{
    rlPhaseStartSetup "cert_request_envsetup"
        #environment setup starts here
        rlPass "no env setup necessary"
        #environment setup ends   here
    rlPhaseEnd
} #envsetup

cert_request_envcleanup()
{
    rlPhaseStartCleanup "cert_request_envcleanup"
        #environment cleanup starts here
        rlPass "no env cleanup necessary"
        #environment cleanup ends   here
    rlPhaseEnd
} #envcleanup

cert_request_1001()
{ #test_scenario (negative): --add --principal;negative;STR --request-type;positive;STR
    rlPhaseStartTest "cert_request_1001: --add --principal;negative;STR --request-type;positive;STR"
        local testID="cert_request_1001_$RANDOM"
        local tmpout=$TmpDir/cert_request_1001.$RANDOM.out
        local request_type_TestValue="pkcs10" #request-type;positive;STR
        local expectedErrCode=0

        local certRequestFile=$TmpDir/certrequest.$RANDOM.certreq.csr
        local certPrivateKeyFile=$TmpDir/certrequest.$RANDOM.prikey.txt
        create_cert_request_file $certRequestFile $certPrivateKeyFile

        KinitAsAdmin
        local principal_TestValue_Negative="/$hostname" #principal;negative;STR 
        local expectedErrMsg="Service principal is not of the form: service/fully-qualified"
        qaRun "ipa cert-request $certRequestFile --add  --principal=$principal_TestValue_Negative  --request-type=$request_type_TestValue " "$tmpout" $expectedErrCode "$expectedErrMsg" "test options:  [principal]=[$principal_TestValue_Negative] [request-type]=[$request_type_TestValue]" 

        principal_TestValue_Negative="noHostNamePricipal" #principal;negative;STR 
        expectedErrMsg="Service principal is not of the form: service/fully-qualified host name: missing service"
        qaRun "ipa cert-request $certRequestFile --add  --principal=$principal_TestValue_Negative  --request-type=$request_type_TestValue " "$tmpout" $expectedErrCode "$expectedErrMsg" "test options:  [principal]=[$principal_TestValue_Negative] [request-type]=[$request_type_TestValue]" 

        principal_TestValue_Negative="whateverservice/does.not.match.csr.host.com" #principal;negative;STR 
        expectedErrMsg="Insufficient access: hostname in subject of request '$hostname' does not match principal hostname 'does.not.match.csr.host.com'"
        qaRun "ipa cert-request $certRequestFile --add  --principal=$principal_TestValue_Negative  --request-type=$request_type_TestValue " "$tmpout" $expectedErrCode "$expectedErrMsg" "test options:  [principal]=[$principal_TestValue_Negative] [request-type]=[$request_type_TestValue]" 

        Kcleanup

        rm $tmpout
        rm $certRequestFile 
        rm $certPrivateKeyFile
    rlPhaseEnd
} #cert_request_1001

cert_request_1002()
{ #test_scenario (negative): --add --principal;positive;STR --request-type;negative;STR
    rlPhaseStartTest "cert_request_1002: --add --principal;positive;STR --request-type;negative;STR"
        local testID="cert_request_1002_$RANDOM"
        local tmpout=$TmpDir/cert_request_1002.$RANDOM.out
        local certRequestFile=$TmpDir/certrequest.$RANDOM.certreq.csr
        local certPrivateKeyFile=$TmpDir/certrequest.$RANDOM.prikey.txt
        create_cert_request_file $certRequestFile $certPrivateKeyFile
        KinitAsAdmin
        local principal_TestValue="sevice$testID/$hostname" #principal;positive;STR 
        local request_type_TestValue_Negative="invalidType100" #request-type;negative;STR
        local expectedErrMsg="Unknown Certificate Request Type"
        local expectedErrCode=0
        qaRun "ipa cert-request $certRequestFile --add  --principal=$principal_TestValue  --request-type=$request_type_TestValue_Negative " "$tmpout" $expectedErrCode "$expectedErrMsg" "test options:  [principal]=[$principal_TestValue] [request-type]=[$request_type_TestValue_Negative]" 
        Kcleanup
        rm $tmpout
        rm $certRequestFile 
        rm $certPrivateKeyFile
    rlPhaseEnd
} #cert_request_1002

cert_request_1003()
{ #test_scenario (positive): --add --principal;positive;STR --request-type;positive;STR
    rlPhaseStartTest "cert_request_1003: --add --principal;positive;STR --request-type;positive;STR"
        local testID="cert_request_1003_$RANDOM"
        local tmpout=$TmpDir/cert_request_1003.$RANDOM.out
        local certRequestFile=$TmpDir/certrequest.$RANDOM.certreq.csr
        local certPrivateKeyFile=$TmpDir/certrequest.$RANDOM.prikey.txt
        create_cert_request_file $certRequestFile $certPrivateKeyFile
        KinitAsAdmin
        local principal_TestValue="service$testID/$hostname" #principal;positive;STR 
        local request_type_TestValue="pkcs10" #request-type;positive;STR
        rlRun "ipa cert-request $certRequestFile --add  --principal=$principal_TestValue  --request-type=$request_type_TestValue " 0 "test options:  [principal]=[$principal_TestValue] [request-type]=[$request_type_TestValue]" 
        Kcleanup
        rm $tmpout
        rm $certRequestFile 
        rm $certPrivateKeyFile
    rlPhaseEnd
} #cert_request_1003

cert_request_1004()
{ #test_scenario (negative): --principal;negative;STR
    rlPhaseStartTest "cert_request_1004: --principal;negative;STR"
        local testID="cert_request_1004_$RANDOM"
        local tmpout=$TmpDir/cert_request_1004.$RANDOM.out

        local certRequestFile=$TmpDir/certrequest.$RANDOM.certreq.csr
        local certPrivateKeyFile=$TmpDir/certrequest.$RANDOM.prikey.txt
        create_cert_request_file $certRequestFile $certPrivateKeyFile

        local expectedErrCode=0
        KinitAsAdmin
        local principal_TestValue_Negative="/$hostname" #principal;negative;STR 
        local expectedErrMsg="Service principal is not of the form: service/fully-qualified host name"
        qaRun "ipa cert-request $certRequestFile  --principal=$principal_TestValue_Negative" "$tmpout" $expectedErrCode "$expectedErrMsg" "test options:  [principal]=[$principal_TestValue_Negative]"

        principal_TestValue_Negative="noHostNamePricipal" #principal;negative;STR 
        expectedErrMsg="Service principal is not of the form: service/fully-qualified host name: missing service"
        qaRun "ipa cert-request $certRequestFile --principal=$principal_TestValue_Negative" "$tmpout" $expectedErrCode "$expectedErrMsg" "test options:  [principal]=[$principal_TestValue_Negative]"

        principal_TestValue_Negative="whateverservice/does.not.match.csr.host.com" #principal;negative;STR 
        expectedErrMsg="Insufficient access: hostname in subject of request '$hostname' does not match principal hostname 'does.not.match.csr.host.com'"
        qaRun "ipa cert-request $certRequestFile --principal=$principal_TestValue_Negative" "$tmpout" $expectedErrCode "$expectedErrMsg" "test options:  [principal]=[$principal_TestValue_Negative]"

        Kcleanup

        rm $tmpout
        rm $certRequestFile 
        rm $certPrivateKeyFile
    rlPhaseEnd
} #cert_request_1004

cert_request_1005()
{ #test_scenario (negative): --principal;negative;STR --request-type;positive;STR
    rlPhaseStartTest "cert_request_1005: --principal;negative;STR --request-type;positive;STR"
        local testID="cert_request_1005_$RANDOM"
        local tmpout=$TmpDir/cert_request_1005.$RANDOM.out

        local certRequestFile=$TmpDir/certrequest.$RANDOM.certreq.csr
        local certPrivateKeyFile=$TmpDir/certrequest.$RANDOM.prikey.txt
        create_cert_request_file $certRequestFile $certPrivateKeyFile
        local request_type_TestValue="pkcs10" #request-type;positive;STR
        local expectedErrCode=0
        KinitAsAdmin
        local principal_TestValue_Negative="/$hostname" #principal;negative;STR 
        local expectedErrMsg="Service principal is not of the form: service/fully-qualified host name"
        qaRun "ipa cert-request $certRequestFile --principal=$principal_TestValue_Negative  --request-type=$request_type_TestValue " "$tmpout" $expectedErrCode "$expectedErrMsg" "test options:  [principal]=[$principal_TestValue_Negative] [request-type]=[$request_type_TestValue]" 

        principal_TestValue_Negative="noHostNamePricipal" #principal;negative;STR 
        expectedErrMsg="Service principal is not of the form: service/fully-qualified host name: missing service"
        qaRun "ipa cert-request $certRequestFile --principal=$principal_TestValue_Negative  --request-type=$request_type_TestValue " "$tmpout" $expectedErrCode "$expectedErrMsg" "test options:  [principal]=[$principal_TestValue_Negative] [request-type]=[$request_type_TestValue]" 

        principal_TestValue_Negative="whateverservice/does.not.match.csr.host.com" #principal;negative;STR 
        expectedErrMsg="Insufficient access: hostname in subject of request '$hostname' does not match principal hostname 'does.not.match.csr.host.com'"
        qaRun "ipa cert-request $certRequestFile --principal=$principal_TestValue_Negative  --request-type=$request_type_TestValue " "$tmpout" $expectedErrCode "$expectedErrMsg" "test options:  [principal]=[$principal_TestValue_Negative] [request-type]=[$request_type_TestValue]" 

        principal_TestValue_Negative="service$testID/$hostname" # legal principal name, just not pre-exist;negative;STR 
        expectedErrMsg="The service principal for this request doesn't exist"
        expectedErrCode=0
        qaRun "ipa cert-request $certRequestFile --principal=$principal_TestValue_Negative  --request-type=$request_type_TestValue " "$tmpout" $expectedErrCode "$expectedErrMsg" "test options:  [principal]=[$principal_TestValue_Negative] [request-type]=[$request_type_TestValue]" 
        Kcleanup

        rm $tmpout
        rm $certRequestFile 
        rm $certPrivateKeyFile
    rlPhaseEnd
} #cert_request_1005

cert_request_1006()
{ #test_scenario (positive): --principal;positive;STR
    rlPhaseStartTest "cert_request_1006: --principal;positive;STR"
        local testID="cert_request_1006_$RANDOM"
        local tmpout=$TmpDir/cert_request_1006.$RANDOM.out

        KinitAsAdmin
        local principal_TestValue="service$testID/$hostname" #principal;positive;STR
        rlRun "ipa service-add $principal_TestValue" 0 "add service principal: [$principal_TestValue] before add cert"

        local certRequestFile=$TmpDir/certrequest.$RANDOM.certreq.csr
        local certPrivateKeyFile=$TmpDir/certrequest.$RANDOM.prikey.txt
        create_cert_request_file $certRequestFile $certPrivateKeyFile

        rlRun "ipa cert-request $certRequestFile --principal=$principal_TestValue " 0 "test options:  [principal]=[$principal_TestValue]" 
        Kcleanup

        rm $tmpout
        rm $certRequestFile 
        rm $certPrivateKeyFile
    rlPhaseEnd
} #cert_request_1006

cert_request_1007()
{ #test_scenario (negative): --principal;positive;STR --request-type;negative;STR
    rlPhaseStartTest "cert_request_1007: --principal;positive;STR --request-type;negative;STR"
        local testID="cert_request_1007_$RANDOM"
        local tmpout=$TmpDir/cert_request_1007.$RANDOM.out
        KinitAsAdmin
        local principal_TestValue="service$testID/$hostname" #principal;positive;STR
        rlRun "ipa service-add $principal_TestValue" 0 "add service principal: [$principal_TestValue] before add cert"

        local certRequestFile=$TmpDir/certrequest.$RANDOM.certreq.csr
        local certPrivateKeyFile=$TmpDir/certrequest.$RANDOM.prikey.txt
        create_cert_request_file $certRequestFile $certPrivateKeyFile

        local request_type_TestValue_Negative="invalidType102" #request-type;negative;STR
        local expectedErrMsg="Unknown Certificate Request Type invalidtype10"
        local expectedErrCode=0
        qaRun "ipa cert-request $certRequestFile --principal=$principal_TestValue  --request-type=$request_type_TestValue_Negative " "$tmpout" $expectedErrCode "$expectedErrMsg" "test options:  [principal]=[$principal_TestValue] [request-type]=[$request_type_TestValue_Negative]" 
        Kcleanup

        rm $tmpout
        rm $certRequestFile 
        rm $certPrivateKeyFile
    rlPhaseEnd
} #cert_request_1007

cert_request_1008()
{ #test_scenario (positive): --principal;positive;STR --request-type;positive;STR
    rlPhaseStartTest "cert_request_1008: --principal;positive;STR --request-type;positive;STR"
        local testID="cert_request_1008_$RANDOM"
        local tmpout=$TmpDir/cert_request_1008.$RANDOM.out
        KinitAsAdmin
        local principal_TestValue="service$testID/$hostname" #principal;positive;STR
        rlRun "ipa service-add $principal_TestValue" 0 "add service principal: [$principal_TestValue] before add cert"
        local request_type_TestValue="pkcs10" #request-type;positive;STR

        local certRequestFile=$TmpDir/certrequest.$RANDOM.certreq.csr
        local certPrivateKeyFile=$TmpDir/certrequest.$RANDOM.prikey.txt
        create_cert_request_file $certRequestFile $certPrivateKeyFile

        rlRun "ipa cert-request $certRequestFile --principal=$principal_TestValue  --request-type=$request_type_TestValue " 0 "test options:  [principal]=[$principal_TestValue] [request-type]=[$request_type_TestValue]" 
        Kcleanup

        rm $tmpout
        rm $certRequestFile 
        rm $certPrivateKeyFile
    rlPhaseEnd
} #cert_request_1008

cert_request_1009()
{ #test_scenario (negative): use same cert request file and principle twice, the first will be revoked with reason 4
    rlPhaseStartTest "cert_request_1009: use same cert request file and principle twice, the first will be revoked with reason 4"
        local testID="cert_request_1009_$RANDOM"
        local tmpout=$TmpDir/cert_request_1009.$RANDOM.out
        local certfile=$TmpDir/cert_request_1009.$RANDOM.certs
        KinitAsAdmin
        local principal="service$testID/$hostname" #principal;positive;STR
        rlRun "ipa service-add $principal" 0 "add service principal: [$principal_TestValue] before add cert"

        local certRequestFile=$TmpDir/certrequest.$RANDOM.certreq.csr
        local certPrivateKeyFile=$TmpDir/certrequest.$RANDOM.prikey.txt
        create_cert_request_file $certRequestFile $certPrivateKeyFile

        # create the first cert, expect success
        ipa cert-request --principal=$principal $certRequestFile 2>&1 >$tmpout
        local ret=$?
        if [ "$ret" = "0" ];then
            local certid=`grep "Serial number" $tmpout| cut -d":" -f2 | xargs echo` 
            echo "$principal=$certid" > $certfile
            rlLog "create first cert success, cert id :[$certid], principal [$principal]"
        else
            rlFail "create first cert failed, principal [$principal]"
            cat $tmpout
        fi

        # create the second cert with same csr file and principal name, expect success as well
        ipa cert-request --principal=$principal $certRequestFile 2>&1 >$tmpout
        local ret=$?
        if [ "$ret" = "0" ];then
            local certid=`grep "Serial number" $tmpout| cut -d":" -f2 | xargs echo` 
            echo "$principal=$certid" >> $certfile
            rlLog "create second cert success, cert id :[$certid], principal [$principal]"
        else
            rlFail "create second cert failed, principal [$principal]"
            cat $tmpout
            return
        fi

        # verification: (1) total success cert count should be 2 in $certfile
        total=`cat $certfile | wc -l` 
        if [ "$total" = "2" ];then
            rlLog "total certs matches : [$total]";
        else
            rlFail "total certs should be 2, but [$total]"
            cat $certfile
            return
        fi
        oldCert=`cat $certfile | head -n1 | cut -d"=" -f2 |cut -d" " -f1`
        newCert=`cat $certfile | tail -n1 | cut -d"=" -f2 |cut -d" " -f1`
        revokeReasonOld=`ipa cert-show $oldCert | grep "Revocation reason" | cut -d":" -f2 | xargs echo`
        if [ "$revokeReasonOld" = "4" ];then
            rlLog "old cert [$oldCert] revoked as reason 4, this is expected, verification continue"
            revokeReasonNew=`ipa cert-show $newCert | grep "Revocation reason" | cut -d":" -f2 | xargs echo`
            if [ "$revokeReasonNew" = "" ];then
                rlPass "newer cert does not being revoked, this is eppected, test pass"
            else
                rlFail "newer cert revoked, this is not expected"
                echo "==========================================="
                echo "--------------- old cert ------------------"
                ipa cert-show $oldCert
                echo "--------------- new cert ------------------"
                ipa cert-show $newCert
                echo "==========================================="
            fi
        else
            rlFail "first cert [$oldCert] Does not being revoked, or not as reason 4, this is not expected"
        fi

        Kcleanup
        rm $tmpout
        rm $certRequestFile 
        rm $certPrivateKeyFile
        rm $certfile
    rlPhaseEnd
} #cert_request_1009

cert_request_1010()
{ #test_scenario (negative): csr given only as argument and service principal does not exists
    rlPhaseStartTest "cert_request_1010: csr given only as argument and service principal does not exists"
        local testID="cert_request_1010_$RANDOM"
        local tmpout=$TmpDir/cert_request_1010.$RANDOM.out
        local exp=$TmpDir/cert_request_1010.$RANDOM.exp
        local certRequestFile=$TmpDir/certrequest.$RANDOM.certreq.csr
        local certPrivateKeyFile=$TmpDir/certrequest.$RANDOM.prikey.txt
        local principal_TestValue="sevice$testID/$hostname" 
        create_cert_request_file $certRequestFile $certPrivateKeyFile
        
        KinitAsAdmin

        local cmd="ipa cert-request $certRequestFile"
        echo "set timeout 5" > $exp
        echo "set force_conservative 0" >> $exp
        echo "set send_slow {1 .1}" >> $exp
        echo "spawn $cmd" >> $exp
        echo 'expect "Principal *"' >> $exp
        echo "send -s -- \"$principal_TestValue\r\"" >> $exp
        echo 'expect eof ' >> $exp
        /usr/bin/expect $exp > $tmpout 2>&1
    
        if grep -i "ipa: ERROR: The service principal for this request doesn't exist." $tmpout
         then
            rlPass "Certificate not generated because service principal does not exits"
            cat $tmpout
        else
            rlFail "Certificate is generated even without service principal does not exists"
        fi

        Kcleanup
        rm $tmpout
        rm $certRequestFile
        rm $certPrivateKeyFile
    rlPhaseEnd
} #cert_request_1010

cert_request_1011()
{ #test_scenario (Positive): csr given only as argument after service principal added through ipa service-add
    rlPhaseStartTest "cert_request_1011: csr given only as argument after service principal added through ipa service-add"
        local testID="cert_request_1011_$RANDOM"
        local tmpout=$TmpDir/cert_request_1011.$RANDOM.out
        local exp=$TmpDir/cert_request_1011.$RANDOM.exp
        local certRequestFile=$TmpDir/certrequest.$RANDOM.certreq.csr
        local certPrivateKeyFile=$TmpDir/certrequest.$RANDOM.prikey.txt
        local principal_TestValue="sevice$testID/$hostname"
        create_cert_request_file $certRequestFile $certPrivateKeyFile

        KinitAsAdmin
        ipa service-add $principal_TestValue
        local cmd="ipa cert-request $certRequestFile"
        echo "set timeout 5" > $exp
        echo "set force_conservative 0" >> $exp
        echo "set send_slow {1 .1}" >> $exp
        echo "spawn $cmd" >> $exp
        echo 'expect "Principal *"' >> $exp
        echo "send -s -- \"$principal_TestValue\r\"" >> $exp
        echo 'expect eof ' >> $exp
        /usr/bin/expect $exp > $tmpout 2>&1

        if grep -i "Serial number" $tmpout
         then
            rlPass "Certificate generated for service principal $principal_TestValue"
            cat $tmpout
        else
            rlFail "Certificate not generated for service principal $principal_TestValue"
        fi

        Kcleanup
        rm $tmpout
        rm $certRequestFile
        rm $certPrivateKeyFile
    rlPhaseEnd
} #cert_request_1011

cert_request_1012()
{ #test_scenario (negative): incorrect csr given as argument after service principal added through ipa service-add
    rlPhaseStartTest "cert_request_1012: incorrect csr given as argument after service principal added through ipa service-add"
        local testID="cert_request_1012_$RANDOM"
        local tmpout=$TmpDir/cert_request_1012.$RANDOM.out
        local exp=$TmpDir/cert_request_1012.$RANDOM.exp
        local certRequestFile=$TmpDir/certrequest.$RANDOM.certreq.csr
        local certPrivateKeyFile=$TmpDir/certrequest.$RANDOM.prikey.txt
        local principal_TestValue="sevice$testID/$hostname"
        create_cert_request_file $certRequestFile $certPrivateKeyFile

        KinitAsAdmin
        ipa service-add $principal_TestValue
        echo "jkdsfldsfjldsfds" > $certRequestFile
        local cmd="ipa cert-request $certRequestFile"
        echo "set timeout 5" > $exp
        echo "set force_conservative 0" >> $exp
        echo "set send_slow {1 .1}" >> $exp
        echo "spawn $cmd" >> $exp
        echo 'expect "Principal *"' >> $exp
        echo "send -s -- \"$principal_TestValue\r\"" >> $exp
        echo 'expect eof ' >> $exp
        /usr/bin/expect $exp > $tmpout 2>&1

        if grep -i "ipa: ERROR: Certificate operation cannot be completed: Failure decoding Certificate Signing Request" $tmpout
         then
            rlPass "Certificate cannot generated for service principal $principal_TestValue as csr is corrupted"
            cat $tmpout
        else
            rlFail "Certificate generated for service principal $principal_TestValue even for csr is corrupted"
            cat $tmpout
        fi

        Kcleanup
        rm $tmpout
        rm $certRequestFile
        rm $certPrivateKeyFile
    rlPhaseEnd
} #cert_request_1012

cert_request_1013()
{ #test_scenario (positive): csr given as argument along with --add option
    rlPhaseStartTest "cert_request_1013: csr given as argument along with --add option"
        local testID="cert_request_1013_$RANDOM"
        local tmpout=$TmpDir/cert_request_1013.$RANDOM.out
        local exp=$TmpDir/cert_request_1013.$RANDOM.exp
        local certRequestFile=$TmpDir/certrequest.$RANDOM.certreq.csr
        local certPrivateKeyFile=$TmpDir/certrequest.$RANDOM.prikey.txt
        local principal_TestValue="sevice$testID/$hostname"
        create_cert_request_file $certRequestFile $certPrivateKeyFile

        KinitAsAdmin
        local cmd="ipa cert-request $certRequestFile --add"
        echo "set timeout 5" > $exp
        echo "set force_conservative 0" >> $exp
        echo "set send_slow {1 .1}" >> $exp
        echo "spawn $cmd" >> $exp
        echo 'expect "Principal *"' >> $exp
        echo "send -s -- \"$principal_TestValue\r\"" >> $exp
        echo 'expect eof ' >> $exp
        /usr/bin/expect $exp > $tmpout 2>&1

        if grep -i "Serial number" $tmpout
         then
            rlPass "Certificate generated for service principal $principal_TestValue"
            cat $tmpout
        else
            rlFail "Certificate not generated for service principal $principal_TestValue"
        fi

        Kcleanup
        rm $tmpout
        rm $certRequestFile
        rm $certPrivateKeyFile
    rlPhaseEnd
} #cert_request_1013
 
cert_request_1014()
{ #test_scenario (Positive): csr--positive and request-type --positive as arguments 
    rlPhaseStartTest "cert_request_1014: csr--positive and request-type --positive as arguments"
        local testID="cert_request_1014_$RANDOM"
        local tmpout=$TmpDir/cert_request_1014.$RANDOM.out
        local exp=$TmpDir/cert_request_1014.$RANDOM.exp
        local certRequestFile=$TmpDir/certrequest.$RANDOM.certreq.csr
        local certPrivateKeyFile=$TmpDir/certrequest.$RANDOM.prikey.txt
        local principal_TestValue="sevice$testID/$hostname"
        local request_format="pkcs10"
        create_cert_request_file $certRequestFile $certPrivateKeyFile 

        KinitAsAdmin
        local cmd="ipa cert-request $certRequestFile --add --request-type=$request_format"
        echo "set timeout 5" > $exp
        echo "set force_conservative 0" >> $exp
        echo "set send_slow {1 .1}" >> $exp
        echo "spawn $cmd" >> $exp
        echo 'expect "Principal *"' >> $exp
        echo "send -s -- \"$principal_TestValue\r\"" >> $exp
        echo 'expect eof ' >> $exp
        /usr/bin/expect $exp > $tmpout 2>&1

        if grep -i "Serial number" $tmpout
         then
            rlPass "Certificate generated for service principal $principal_TestValue"
            cat $tmpout
        else
            rlFail "Certificate not generated for service principal $principal_TestValue"
        fi

        Kcleanup
        rm $tmpout
        rm $certRequestFile
        rm $certPrivateKeyFile
    rlPhaseEnd
} #cert_request_1014

cert_request_1015()
{ #test_scenario (Positive): csr--positive and request-type --negative as arguments 
    rlPhaseStartTest "cert_request_1015: csr--positive and request-type --negative as arguments"
        local testID="cert_request_1015_$RANDOM"
        local tmpout=$TmpDir/cert_request_1015.$RANDOM.out
        local exp=$TmpDir/cert_request_1015.$RANDOM.exp
        local certRequestFile=$TmpDir/certrequest.$RANDOM.certreq.csr
        local certPrivateKeyFile=$TmpDir/certrequest.$RANDOM.prikey.txt
        local principal_TestValue="sevice$testID/$hostname"
        local request_format="invalid"
        create_cert_request_file $certRequestFile $certPrivateKeyFile

        KinitAsAdmin
        local cmd="ipa cert-request $certRequestFile --add --request-type=$request_format"
        echo "set timeout 5" > $exp
        echo "set force_conservative 0" >> $exp
        echo "set send_slow {1 .1}" >> $exp
        echo "spawn $cmd" >> $exp
        echo 'expect "Principal *"' >> $exp
        echo "send -s -- \"$principal_TestValue\r\"" >> $exp
        echo 'expect eof ' >> $exp
        /usr/bin/expect $exp > $tmpout 2>&1

        if grep -i "FAILURE (Unknown Certificate Request Type invalid)" $tmpout
         then
            rlPass "Certificate not generated because request-type is not correct"
            cat $tmpout
        else
            rlFail "Certificate is generated even request-type is not correct"
        fi

        Kcleanup
        rm $tmpout
        rm $certRequestFile
        rm $certPrivateKeyFile
    rlPhaseEnd
} #cert_request_1015

cert_request_1016()
{ #test_scenario (Negative): csr--positive , --principal -- negative and request-type --negative as arguments 
    rlPhaseStartTest "cert_request_1016: csr--positive , --principal -- negative and request-type --negative as arguments"
        local testID="cert_request_1016_$RANDOM"
        local tmpout=$TmpDir/cert_request_1016.$RANDOM.out
        local exp=$TmpDir/cert_request_1016.$RANDOM.exp
        local certRequestFile=$TmpDir/certrequest.$RANDOM.certreq.csr
        local certPrivateKeyFile=$TmpDir/certrequest.$RANDOM.prikey.txt
        #local principal_TestValue="sevice$testID/$hostname"
        local principal_TestValue="sevice$testID/"
        local request_format="invalid"
        create_cert_request_file $certRequestFile $certPrivateKeyFile

        KinitAsAdmin
        local cmd="ipa cert-request $certRequestFile --add --principal=$principal_TestValue --request-type=$request_format"
        echo "set timeout 5" > $exp
        echo "set force_conservative 0" >> $exp
        echo "set send_slow {1 .1}" >> $exp
        echo "spawn $cmd" >> $exp
        echo 'expect "Principal *"' >> $exp
        echo "send -s -- \"$principal_TestValue\r\"" >> $exp
        echo 'expect eof ' >> $exp
        /usr/bin/expect $exp > $tmpout 2>&1

        if grep -i "Insufficient access: hostname in subject of request '`hostname`' does not match principal hostname ''" $tmpout
         then
            rlPass "Certificate not generated because principal provided is not correct"
            cat $tmpout
        else
            rlFail "Certificate is generated even principal provided is not correct"
        fi

        Kcleanup
        rm $tmpout
        rm $certRequestFile
        rm $certPrivateKeyFile
    rlPhaseEnd
} #cert_request_1016

cert_request_1017()
{ #test_scenario (Positive): key-sizes --3072,4096
    rlPhaseStartTest "cert_request_1017: key-sizes --3072,4096"
        local testID="cert_request_1017_$RANDOM"
        local tmpout=$TmpDir/cert_request_1017.$RANDOM.out
        local exp=$TmpDir/cert_request_1017.$RANDOM.exp
        local certRequestFile=$TmpDir/certrequest.$RANDOM.certreq.csr
        local certPrivateKeyFile=$TmpDir/certrequest.$RANDOM.prikey.txt
        local principal_TestValue="sevice$testID/$hostname"
        local request_format="pkcs10"
        for keysize in 3072 4096;do
        create_cert_request_file $certRequestFile $certPrivateKeyFile $keysize

        KinitAsAdmin
        local cmd="ipa cert-request $certRequestFile --add --request-type=$request_format"
        echo "set timeout 5" > $exp
        echo "set force_conservative 0" >> $exp
        echo "set send_slow {1 .1}" >> $exp
        echo "spawn $cmd" >> $exp
        echo 'expect "Principal *"' >> $exp
        echo "send -s -- \"$principal_TestValue\r\"" >> $exp
        echo 'expect eof ' >> $exp
        /usr/bin/expect $exp > $tmpout 2>&1

        if grep -i "Serial number" $tmpout
         then
            rlPass "Certificate generated for keysize [$keysize]"
            cat $tmpout
        else
            rlFail "Certificate not generated for [$keysize]"
        fi
        done
        Kcleanup
        rm $tmpout
        rm $certRequestFile
        rm $certPrivateKeyFile
    rlPhaseEnd
} #cert_request_1017

#END OF TEST CASE for [cert-request]

#############################################
#  test suite: cert-revoke (3 test cases)
#############################################
cert_revoke()
{
    cert_revoke_envsetup
    cert_revoke_1001  #test_scenario (negative test): [--revocation-reason;negative;-1,11]
    cert_revoke_1002  #test_scenario (positive test): [--revocation-reason;positive;0,1,2,3,4,5,6,7,8,9,10]
    cert_revoke_1003  #test_scenario (negative): revoke an non-exist cert
    cert_revoke_1004  #test_scenario (positive test): [ valid id in decimal --revocation-reason;positive;0,1,2,3,4,5,6,7,8,9,10] #Added by Kaleem
    cert_revoke_1005  #test_scenario (positive test): [ without revocation reason] #Added by Kaleem
    cert_revoke_1006  #test_scenario (negative test): [ Revoking a revoked certificate again] #Added by Kaleem
    cert_revoke_1007  #test_scenario (positive test): [ Revocation reason 7 not supported] #Added by Kaleem
    cert_revoke_1008  #test_scenario (negative test): [ no cert id provided and given on prompt] #Added by Kaleem
    cert_revoke_1009  #test_scenario (negative test): [ empty --revocation-reason provided] #Added by Kaleem
    cert_revoke_envcleanup
} #cert-revoke

cert_revoke_envsetup()
{
    rlPhaseStartSetup "cert_revoke_envsetup"
        #environment setup starts here
        rlPass "no env setup necessare, all certs will be created in each test case"
        #environment setup ends   here
    rlPhaseEnd
} #envsetup

cert_revoke_envcleanup()
{
    rlPhaseStartCleanup "cert_revoke_envcleanup"
        #environment cleanup starts here
        rlPass "no env cleanup necessary, it is already done in each test case"
        #environment cleanup ends   here
    rlPhaseEnd
} #envcleanup

cert_revoke_1001()
{ #test_scenario (negative): valid cert id + --revocation-reason;negative;-1,11
    rlPhaseStartTest "cert_revoke_1001: valid cert id + --revocation-reason;negative;-1,11"
        local testID="cert_revoke_1001"
        local tmpout=$TmpDir/cert_revoke_1001.$RANDOM.out
        local expectedErrMsg="invalid 'revocation_reason': must be an integer"
        local expectedErrCode=0
        create_cert
        local validCert=`tail -n1 $certList`
        local certid=`echo $validCert| cut -d"=" -f2 | cut -d" " -f1`
        rlLog "certid=[$certid]";
        echo "================ cert list =============";
        cat  $certList
        echo "========================================";
        KinitAsAdmin
        # when pass a non-integer
        for invalid_revoke_reason in a abc
        do
            qaRun "ipa cert-revoke $certid --revocation-reason=$invalid_revoke_reason" "$tmpout" "$expectedErrCode" "$expectedErrMsg" "test options:  [revocation-reason]=[$invalid_revoke_reason]" 
        done

        # when interger does pass in, error msg indicates max value
        invalid_revoke_reason=99
        expectedErrMsg="invalid 'revocation_reason': can be at most 10"
        qaRun "ipa cert-revoke $certid --revocation-reason=$invalid_revoke_reason" "$tmpout" "$expectedErrCode" "$expectedErrMsg" "test options:  [revocation-reason]=[$invalid_revoke_reason]" 
        Kcleanup
        delete_cert
        rm $tmpout
    rlPhaseEnd
} #cert_revoke_1001

cert_revoke_1002()
{ #test_scenario (positive): valid cert id (in decimal) + --revocation-reason;positive;0,1,2,3,4,5,6,8,9,10
    rlPhaseStartTest "cert_revoke_1002: valid cert id (in decimal) + --revocation-reason;positive;0,1,2,3,4,5,6,8,9,10"
        local testID="cert_revoke_1002"
        local tmpout=$TmpDir/certrevoke1002.$RANDOM.out
        for reason in 0 1 2 3 4 5 6 8 9 10
        do
            create_cert
            local validCert=`tail -n1 $certList`
            local certid=`echo $validCert| cut -d"=" -f2 | cut -d" " -f1`
            rlLog "revoke cert [$certid] with revoke reason [$reason]"
            KinitAsAdmin
            ipa cert-revoke $certid --revocation-reason=$reason
            local ret=$?
            if [ "$ret" = "0" ];then
                ipa cert-show $certid > $tmpout
                rlLog "revocation success, now check the revocation code"
                local actual=`grep -i "Revocation reason" $tmpout | cut -d":" -f2 | xargs echo`
                if [ "$reason" = "$actual" ];then
                    rlPass "revocation code matches with expected [$actual], pass"
                else
                    rlFail "revocation code doesnot match with expected: expected [$reason], actual [$actual] "
                    ipa cert-show $certid 
                fi
            else
                rlFail "revocation failed, cert show:"
                ipa cert-show $certid 
            fi
            Kcleanup
            delete_cert
        done
        rm $tmpout
    rlPhaseEnd
} #cert_revoke_1002

cert_revoke_1003()
{ #test_scenario (negative):revoke a non-exist cert
    rlPhaseStartTest "cert_revoke_1003: revoke a non-exist cert"
        local testID="cert_revoke_1003"
        KinitAsAdmin
        for invalid_cert in z abc 100abc 10000000000
        do
            rlRun "ipa cert-revoke $invalid_cert" 1 "revoke non-exist cert should fail certid=[$invalid_cert]"
        done
        Kcleanup
    rlPhaseEnd
} #cert_revoke_1002

cert_revoke_1004()
{ #test_scenario (positive): valid cert id (in decimal) + --revocation-reason;positive;0,1,2,3,4,5,6,8,9,10
    rlPhaseStartTest "cert_revoke_1004: valid cert id (in decimal) + --revocation-reason;positive;0,1,2,3,4,5,6,8,9,10"
        local testID="cert_revoke_1004"
        local tmpout=$TmpDir/certrevoke1004.$RANDOM.out
        for reason in 0 1 2 3 4 5 6 8 9 10
        do
            create_cert
            local validCert=`tail -n1 $certList`
            local certid=`echo $validCert| cut -d"=" -f2 | cut -d" " -f2`
            echo $certid
            rlLog "revoke cert [$certid] with revoke reason [$reason]"
            KinitAsAdmin
            ipa cert-revoke $certid --revocation-reason=$reason
            local ret=$?
            if [ "$ret" = "0" ];then
                ipa cert-show $certid > $tmpout
                rlLog "revocation success, now check the revocation code"
                local actual=`grep -i "Revocation reason" $tmpout | cut -d":" -f2 | xargs echo`
                if [ "$reason" = "$actual" ];then
                    rlPass "revocation code matches with expected [$actual], pass"
                else
                    rlFail "revocation code doesnot match with expected: expected [$reason], actual [$actual] "
                    ipa cert-show $certid
                fi
            else
                rlFail "revocation failed, cert show:"
                ipa cert-show $certid
            fi
            Kcleanup
            delete_cert
        done
        rm $tmpout
    rlPhaseEnd
} #cert_revoke_1004

cert_revoke_1005()
{ #test_scenario (positive): without revocation-reason provided
    rlPhaseStartTest "cert_revoke_1005: without revocation-reason provided"
        local testID="cert_revoke_1005"
        local tmpout=$TmpDir/certrevoke1005.$RANDOM.out
          create_cert
            local validCert=`tail -n1 $certList`
            local certid=`echo $validCert| cut -d"=" -f2 | cut -d" " -f2`
            echo $certid
            rlLog "revoke cert [$certid] with default revoke reason [0] "
            KinitAsAdmin
            ipa cert-revoke $certid
            local ret=$?
            if [ "$ret" = "0" ];then
                ipa cert-show $certid > $tmpout
                rlLog "revocation success, now check the revocation code"
                local actual=`grep -i "Revocation reason" $tmpout | cut -d":" -f2 | xargs echo`
                if [ "$actual" -eq 0 ];then
                    rlPass "revocation code is [$actual] which is default revocation code [0]"
                else
                    rlFail "revocation code is [$actual] which is not default revocation code"
                    ipa cert-show $certid
                fi
            else
                rlFail "revocation failed, cert show:"
                ipa cert-show $certid
            fi
            Kcleanup
            delete_cert
        rm $tmpout
    rlPhaseEnd
} #cert_revoke_1005

cert_revoke_1006()
{ #test_scenario (positive): revoking a revoked certificate 
    rlPhaseStartTest "cert_revoke_1006: revoking a revoked certificate"
        local testID="cert_revoke_1006"
        local tmpout=$TmpDir/certrevoke1006.$RANDOM.out
          create_cert
            local validCert=`tail -n1 $certList`
            local certid=`echo $validCert| cut -d"=" -f2 | cut -d" " -f2`
            echo $certid
            rlLog "revoke cert [$certid] with default revoke reason [0] "
            KinitAsAdmin
            ipa cert-revoke $certid
            ipa cert-revoke $certid > $tmpout
                
                local actual=`grep -i "ERROR (Attempt to revoke non-existent certificate(s).)" $tmpout`
                if [ $? -eq 0 ];then
                    rlPass "Revoked certificate cannot be revoked again"
                else
                    rlFail "Revoked certificate can be revoked again"
                fi
            Kcleanup
            delete_cert
        rm $tmpout
    rlPhaseEnd
} #cert_revoke_1006

cert_revoke_1007()
{ #test_scenario (positive): valid cert id + --revocation-reason is 7
    rlPhaseStartTest "cert_revoke_1007: valid cert id + --revocation-reason is 7"
        local testID="cert_revoke_1007"
        local tmpout=$TmpDir/cert_revoke_1007.$RANDOM.out
        local expectedErrMsg="7 is not a valid revocation reason"
        local expectedErrCode=0
        local invalid_revoke_reason=7
        create_cert
        KinitAsAdmin
        for cert in `cat $certList`;do
          echo $cert
          local certid=`echo $cert | cut -d"=" -f2`
          echo $certid
          ipa cert-revoke $certid --revocation-reason=$invalid_revoke_reason > $tmpout 2>&1 
          cat $tmpout
           local actual=`grep -i "7 is not a valid revocation reason" $tmpout`
            if [ $? -eq 0 ];then
              rlPass "Revoked reason 7 not supported"
            else
              rlFail "Revoked reason 7 is supported"
            fi
        done
        delete_cert
        rm $tmpout
    rlPhaseEnd
} #cert_revoke_1007

cert_revoke_1008()
{ #test_scenario (negative): no cert id provided 
    rlPhaseStartTest "cert_revoke_1008: no cert id provided"
        local testID="cert_revoke_1008"
        local tmpout=$TmpDir/cert_revoke_1008.$RANDOM.out
        local exp=$TmpDir/createCertRequestFile.$RANDOM.exp # beaker test
        create_cert
        KinitAsAdmin
        for cert in `cat $certList`;do
          echo $cert
          local certid=`echo $cert | cut -d"=" -f2`
          echo $certid
          local cmd="ipa cert-revoke --revocation-reason=6"
          echo "set timeout 5" > $exp
          echo "set force_conservative 0" >> $exp
          echo "set send_slow {1 .1}" >> $exp
          echo "spawn $cmd" >> $exp
          echo 'expect "Serial number *"' >> $exp
          echo "send -s -- \"$certid\r\"" >> $exp
          echo 'expect eof ' >> $exp
          /usr/bin/expect $exp
          ipa cert-show $certid > $tmpout 2>&1 
           local actual=`grep -i "Revocation reason: 6" $tmpout`
            if [ $? -eq 0 ];then
              rlPass "Certificate is revoked successfully with --revocation reason 6"
            else
              rlFail "Certificate is not revoked with --revocation reason 6"
            fi
         ipa cert-remove_hold $certid
        done
        delete_cert
        rm $tmpout
    rlPhaseEnd
} #cert_revoke_1008

cert_revoke_1009()
{ #test_scenario (negative): empty --revocation-reason provided
    rlPhaseStartTest "cert_revoke_1009: empty --revocation-reason provided"
    #    local testID="cert_revoke_1009"
        local tmpout=$TmpDir/cert_revoke_1009.$RANDOM.out
        create_cert
        KinitAsAdmin
        for cert in `cat $certList`;do
          echo $cert
          local certid=`echo $cert | cut -d"=" -f2`
          echo $certid
          ipa cert-revoke $certid --revocation-reason= > $tmpout 2>&1
          cat $tmpout
           local actual=`grep -i "ipa: ERROR: 'revocation_reason' is required" $tmpout`
            if [ $? -eq 0 ];then
              rlPass "revocation_reason argument can not be empty"
            else
              rlFail "revocation_reason argument can be empty"
            fi
        done
        delete_cert
        rm $tmpout
    rlPhaseEnd
} #cert_revoke_1009

#END OF TEST CASE for [cert-revoke]

#############################################
#  test suite: cert-show (2 test cases)
#############################################
cert_show()
{
    cert_show_envsetup
    cert_show_1001  #test_scenario (negative test): give negative cert id 
    cert_show_1002  #test_scenario (positive test): [--out;positive;CertOutFile]
    cert_show_1003  #test_scenario (negative test): valid cert id + --out;negative;CertOutFile]
    cert_show_1004  #test_scenario (negative test): invalid cert id + --out--positive] #Added by Kaleem
    cert_show_1005  #test_scenario (positive test): revoked certificate is shown with ipa-cert-show] #Added by kaleem
    cert_show_1006  #test_scenario (negative test): invalid cert request id other than decimal or hexadecimal] #Added by kaleem
    cert_show_envcleanup
} #cert-show

cert_show_envsetup()
{
    rlPhaseStartSetup "cert_show_envsetup"
        #environment setup starts here
        create_cert
        #environment setup ends   here
    rlPhaseEnd
} #envsetup

cert_show_envcleanup()
{
    rlPhaseStartCleanup "cert_show_envcleanup"
        #environment cleanup starts here
        delete_cert
        #environment cleanup ends   here
    rlPhaseEnd
} #envcleanup

cert_show_1001()
{ #test_scenario (negative): given invalid cert request id
    rlPhaseStartTest "cert_show_1001: given invalid cert request id"
        local testID="cert_show_1001"
        local tmpout=$TmpDir/cert_show_1001.$RANDOM.out
        KinitAsAdmin
        local expectedErrMsg="not found"
        local expectedErrCode=0
        for invalidCertID in 1000 2000 ;do
            qaRun "ipa cert-show $invalidCertID" "$tmpout" $expectedErrCode "$expectedErrMsg" "test options: $invalidCertID" 
        done

        local expectedErrMsg="Certificate operation cannot be completed"
        local expectedErrCode=0
        for invalidCertID in abc b0a;do
            qaRun "ipa cert-show $invalidCertID" "$tmpout" $expectedErrCode "$expectedErrMsg" "test options: $invalidCertID" 
        done
        Kcleanup
        rm $tmpout
    rlPhaseEnd
} #cert_show_1001

cert_show_1002()
{ #test_scenario (positive): --out;positive;CertOutFile
    rlPhaseStartTest "cert_show_1002: --out;positive;CertOutFile"
        local testID="cert_show_1002"
        local tmpout=$TmpDir/cert_show_1002.$RANDOM.out
        KinitAsAdmin
        for cert in `cat $certList`;do
            local outfile=$TmpDir/certshow1002.$RANDOM.out.file
            local output=$TmpDir/certshow1002.$RANDOM.output
            local valid_certid=`echo $cert | cut -d"=" -f2`
            echo $valid_certid
            rlRun "ipa cert-show $valid_certid --out=$outfile" 0 "output [$valid_certid] to file: [$outfile]"
            if [ -f $outfile ];then
                if     grep "BEGIN CERTIFICATE" $outfile 2>&1 >/dev/null \
                    && grep "END CERTIFICATE" $outfile 2>&1 >/dev/null
                then
                    rlPass "cert-show output to file [$outfile] success"
                else
                    rlFail "cert-show output to file [$outfile] failed"
                fi
            else
                rlFail "can not output cert to file [$outfile]"
            fi
            rm $outfile
        done
        Kcleanup
        rm $tmpout
    rlPhaseEnd
} #cert_show_1002

cert_show_1003()
{ #test_scenario (negative): positive cert id + --out;negative;CertOutFile
    rlPhaseStartTest "cert_show_1003: positive cert id + --out;negative;CertOutFile"
        local testID="cert_show_1003"
        local tmpout=$TmpDir/cert_show_1003.$RANDOM.out
        local errcode=0;
        KinitAsAdmin
        for cert in `cat $certList`;do
            local valid_certid=`echo $cert | cut -d"=" -f2`
            qaRun "ipa cert-show $valid_certid --out=" "$tmpout" "$errcode" "Filename is empty" "test option: give no argument for --out, expect to fail"
            qaRun "ipa cert-show $valid_certid --out=/" "$tmpout" "$errcode" "Is a directory" "test option: give a directory location instead of file name, expecte to fail"
        done
        Kcleanup
        rm $tmpout
    rlPhaseEnd
} #cert_show_1003

cert_show_1004()
{ #test_scenario (negative): serial no--negative ; out--positive
    rlPhaseStartTest "cert_show_1004: serial no--negative ; out--positive"
        local testID="cert_show_1004"
        local tmpout=$TmpDir/cert_show_1004.$RANDOM.out
        KinitAsAdmin
            local expectedErrMsg="not found"
            local expectedErrCode=0
            local outfile=$TmpDir/certshow1004.$RANDOM.out.file
            for invalidCertID in 1000 2000 ;do
              qaRun "ipa cert-show $invalidCertID --out=$outfile" "$tmpout" $expectedErrCode "$expectedErrMsg" "test options: $invalidCertID"
             done
            local expectedErrMsg="Certificate operation cannot be completed"
            local expectedErrCode=0
            for invalidCertID in abc b0a;do
               qaRun "ipa cert-show $invalidCertID --out=$outfile" "$tmpout" $expectedErrCode "$expectedErrMsg" "test options: $invalidCertID"
            done
        Kcleanup
        rm $tmpout
    rlPhaseEnd
} #cert_show_1004
cert_show_1005()
{ #test_scenario (positive): revoked certificate is also shown with status revoked.
    rlPhaseStartTest "cert_show_1005: revoked certificate is also shown with status revoked"
        local testID="cert_show_1005"
        local tmpout=$TmpDir/certshow1005.$RANDOM.out
         for cert in `cat $certList`;do
            local certid=`echo $cert| cut -d"=" -f2`
            rlLog "revoke cert [$certid] with revoke reason 6 "
            KinitAsAdmin
            ipa cert-revoke $certid --revocation-reason=6
            local ret=$?
            if [ "$ret" = "0" ];then
                ipa cert-show $certid > $tmpout
                rlLog "revocation success, now check the revocation code"
                local actual=`grep -i "Revocation reason" $tmpout | cut -d":" -f2 | xargs echo`
                if [ "$actual" -eq 6 ];then
                    rlPass "Revoked certificate is also shown with ipa cert-show"
                else
                    rlPass "Revoked certificate is shown but revocation reason is other than 6"
                    ipa cert-show $certid
                fi
            else
                rlFail "Revoked certificate is not shown with ipa cert-show"
                ipa cert-show $certid
            fi
            ipa cert-remove-hold $certid 
          done
          Kcleanup
        rm $tmpout
    rlPhaseEnd
} #cert_show_1005
cert_show_1006()
{ #test_scenario (negative): given invalid cert request id other than decimal or hexadecimal
    rlPhaseStartTest "cert_show_1006: given invalid cert request id other than decimal or hexadecimal"
        local testID="cert_show_1006"
        local tmpout=$TmpDir/cert_show_1006.$RANDOM.out
        KinitAsAdmin
        local expectedErrMsg="Decimal or hexadecimal number is required for serial number"
        local expectedErrCode=0
        invalidCertID=A@
            qaRun "ipa cert-show $invalidCertID" "$tmpout" $expectedErrCode "$expectedErrMsg" "test options: $invalidCertID"
        Kcleanup
        rm $tmpout
    rlPhaseEnd
} #cert_show_1006
#END OF TEST CASE for [cert-show]

#############################################
#  test suite: cert-status (2 test cases)
#############################################
cert_status()
{
    cert_status_envsetup
    cert_status_1001  #test_scenario (positive test): valid cert id
    cert_status_1002  #test_scenario (positive test): invalid cert id
    cert_status_envcleanup
} #cert-status

cert_status_envsetup()
{
    rlPhaseStartSetup "cert_status_envsetup"
        #environment setup starts here
        create_cert 
        create_cert 
        #environment setup ends   here
    rlPhaseEnd
} #envsetup

cert_status_envcleanup()
{
    rlPhaseStartCleanup "cert_status_envcleanup"
        #environment cleanup starts here
        delete_cert 
        #environment cleanup ends   here
    rlPhaseEnd
} #envcleanup

cert_status_1001()
{ #test_scenario (positive): valid cert id
    rlPhaseStartTest "cert_status_1001: valid cert id"
        local testID="cert_status_1001"
        local tmpout=$TmpDir/cert_status_1001.$RANDOM.out
        KinitAsAdmin
        for reqid in `cat $reqList`
        do
            echo $reqid
            #local word=service
            #echo "$cert" | grep -q "$word"
            #if [ $? -eq 0 ];then
             #local cert_principal=`echo $cert | cut -d"=" -f1`
             #local certid=`echo $cert | cut -d"=" -f2`
             ipa cert-status $reqid 2>&1 >$tmpout
             if     grep -i "Request id: $reqid" $tmpout \
                && grep -i "Request status: complete" $tmpout ;then
                rlPass "status check pass for req id [$reqid]"
             else
                rlFail "status check failed for req id [$reqid]"
                echo "=========== output ================"
                cat $tmpout
                echo "==================================="
             fi
            #else
            #   rlLog "hexadecimal number cannot be used for ipa cert-status"
           #fi
        done
        Kcleanup
        rm $tmpout
    rlPhaseEnd
} #cert_status_1001

cert_status_1002()
{ #test_scenario (negative): invalid cert id
    rlPhaseStartTest "cert_status_1002: invalid cert id"
        local testID="cert_status_1002"
        local tmpout=$TmpDir/cert_status_1002.$RANDOM.out
        KinitAsAdmin
        # scenario 1: give chars and char-integer mix
        for certid in a abc 1a0
        do
            ipa cert-status $certid 2>$tmpout
            local errmsg="Invalid number format"
            if grep -i "$errmsg" $tmpout
            then
                rlPass "error returned as expected for cert id [$certid], errmsg [$errmsg]"
            else
                rlFail "no error returned or error msg not match for cert id [$certid]"
                rlLog "expected errmsg: [$errmsg]"
                echo "=========== output ================"
                cat $tmpout
                echo "==================================="
            fi
        done

        # scenario: give integer, but there are no such cert in ipa
        for certid in 4999 51999
        do
            local errmsg="Request ID $certid was not found in the request queue"
            ipa cert-status $certid 2>$tmpout
            local ret=$?
            if grep -i "$errmsg" $tmpout
            then
                rlPass "error returned as expected for cert id [$certid]"
            else
                rlFail "no error returned or error msg not match for cert id [$certid]"
                rlLog "expected errmsg: [$errmsg]"
                echo "=========== output ================"
                cat $tmpout
                echo "==================================="
            fi
        done
        Kcleanup
        rm $tmpout
    rlPhaseEnd
} #cert_status_1002

cert_BZ()
{
	KinitAsAdmin # Kinit as admin for good measure
	csr_no_description_BZ910468 # Test of a bug reporting a internal service error on a bad csr
}

#END OF TEST CASE for [cert-status]

csr_no_description_BZ910468()
{
	rlPhaseStartTest "cert_bz_0001: Internal server error on CSR with no subject hostname BZ910468"
		ipaddr=$(hostname -i) # Get IP address of this host
		rlLog "Ip address is $ipaddr"
		ipoc1=$(echo $ipaddr | cut -d\. -f1)
		ipoc2=$(echo $ipaddr | cut -d\. -f2)
		ipoc3=$(echo $ipaddr | cut -d\. -f3)
		ipoc4=$(echo $ipaddr | cut -d\. -f4)
		let newip4=$ipoc4+1
		newip="$ipoc1.$ipoc2.$ipoc3.$newip4"
		rlLog "creating new host with IP $newip"
		rlRun "ipa host-add testhostBZ910468.$DOMAIN --ip-address='$newip'" 0 "Creating host to test with this BZ test"
		csrfile="$TmpDir/example.csr"
		rm -f $csrfile
		echo . | openssl req -new -nodes -out $csrfile
		rlRun "ipa cert-request --add --principal=EXAMPLE/testhostBZ910468.$DOMAIN example.csr"
		rlRun "ipa host-del testhostBZ910468.$DOMAIN" 0 "Cleaning up host created for this test."
	rlPhaseEnd
}

export certhost="clicerttesthost.$DOMAIN"

# Start IPA Cert Find CLI tests
cert_find()
{
	KinitAsAdmin # Kinit as admin for good measure

	cert_find_startup
	cert_find_serial_min

	rlRun "ipa host-del $certhost" 0 "Cleaning up created host."
}

# Setup section for the cert-find section
cert_find_startup()
{
	# Create a host to work with
	ipaddr=$(hostname -i) # Get IP address of this host
	rlLog "Ip address is $ipaddr"
	ipoc1=$(echo $ipaddr | cut -d\. -f1)
	ipoc2=$(echo $ipaddr | cut -d\. -f2)
	ipoc3=$(echo $ipaddr | cut -d\. -f3)
	ipoc4=$(echo $ipaddr | cut -d\. -f4)
	let newip4=$ipoc4+2
	newip="$ipoc1.$ipoc2.$ipoc3.$newip4"
	
	rlLog "creating new host with IP $newip"
	rlRun "ipa host-add $certhost --ip-address='$newip'" 0 "Creating host to test with this BZ test"

	# Create a bunch of certs to work with
	current_certs=$(ipa cert-find --all | grep Serial\ number: | wc -l)
	rlLog "Current certs on system is $current_certs"
	# Create CSR config file
	echo '[ req ]
default_bits = 2048
default_keyfile = teste.key
distinguished_name = test_key_file
prompt = no
output_password = ..

[ test_key_file ]
C = US
ST = CA
L = SFO
O = RedHat Technology
OU = RedHat IT' > /opt/rhqa_ipa/cert-req.conf
	echo "CN = $certhost" >> /opt/rhqa_ipa/cert-req.conf
	while [ $current_certs -lt 26 ]; do
		rlRun "openssl req -new -set_serial -config ./opt/rhqa_ipa/cert-req.conf -out /opt/rhqa_ipa/cert-req.csr" 0 "Create a new CSR to work with"
		rlRun "ipa cert-request --add --principal=EXAMPLE/$certhost /opt/rhqa_ipa/cert-req.csr" 0 "Request the csr into IPA"
		let current_certs = $current_certs + 1;
	done
}

cert_find_serial_min()
{
	rlPhaseStartTest "cert_find_001: Positive test of Serial number find min"
		foundcerts=$(ipa cert-find --min-serial-number=15| grep Serial\ number: | wc -l) # This should match 11 certs
		rlLog "Found $foundcerts certs"
		rlRun "echo $foundcerts | grep 11" 0 "Making sure that the correct number of certs was returned."
	rlPhaseEnd
}

#    Serial number range (min/max/none)
#        Serial number range in Hexadecimal (min/max/none) 
#    Issued On
#    revoked certificates
#    subject
#    valid not after from
#    valid not after to
#    valid not before from
#    valid not before to 
