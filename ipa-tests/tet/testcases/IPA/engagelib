#!/bin/ksh

#### Perl Test routines 

SetPerlEnv()
{
  LOCAL_PREFIX=${1:-"$PREFIX"}

  if [ "$LOCAL_PREFIX" = "/" -o "$LOCAL_PREFIX" = ""  ]; then
    LOCAL_PREFIX="/usr"
  fi

# Adding a new file tetexecpl.cfg . This will execute the TET-ENGAGE test suites developed both in korn shell and perl . While
# calling tcc this file tetexecpl.cfg should be called with the -x option ( for ex : tcc -x $TET_ROOT/../tetexecpl.cfg


	# Starting from DS 7.2 we're using the system perl not one stored in tet. 
	echo TET_EXEC_TOOL=perl > $TET_ROOT/../tetexecpl.cfg
	echo TET_EXEC_IN_PLACE=False >> $TET_ROOT/../tetexecpl.cfg

	chmod 755 $TET_ROOT/../tetexecpl.cfg

	TETPERL=perl
	export TETPERL

	case $MainOS in
	SunOS-sparc)

#		if [ ! -d  "$TET_ROOT/../perl/sparc_sun_solaris2.6/lib/nsPerl5.6.1" ] ; then
#		 unzip $TET_ROOT/../perl/sparc_sun_solaris2.6/nsperlsol.zip -d $TET_ROOT/../perl/sparc_sun_solaris2.6
#		else
#			echo "Perl already unzipped"
#		fi
#		$TET_ROOT/../perl/sparc_sun_solaris2.6/lib/nsPerl5.6.1/install

		# DS7.2 Solaris packages 32-bit perldap lib; 
		# Solaris perldap is built by /usr/bin/perl, therefore let's use it.
	    # In addition to using system perl for most perl functionality from 
	    #    DS 7.2 onwards, we also need to use
	    # 1. perldap from the directory installation.
	    # 2. MIME:Base64 within the test framework, which is the only remaining 
	    #    perl module within TET.
		# 3. use nspr/nss libs from the dirsec lib path
		case "$DSTET_64" in
		[yY]*)
			LD_LIBRARY_PATH=$LOCAL_PREFIX/lib/perl/arch/auto/Mozilla/LDAP/API:$LOCAL_PREFIX/lib/dirsec/sparcv9:$LOCAL_PREFIX/lib/sparcv9:$LOCAL_PREFIX/lib/dirsec:$LOCAL_PREFIX/lib:/usr/lib/dirsec/sparcv9:/usr/lib/sparcv9:/usr/lib/dirsec:/usr/lib:$LD_LIBRARY_PATH
			;;
		*)
			LD_LIBRARY_PATH=$LOCAL_PREFIX/lib/perl/arch/auto/Mozilla/LDAP/API:$LOCAL_PREFIX/lib/dirsec:$LOCAL_PREFIX/lib:/usr/lib/dirsec:/usr/lib:$LD_LIBRARY_PATH
			;;
		esac
		export LD_LIBRARY_PATH
		PERL5LIB=$LOCAL_PREFIX/lib/perl/
		export PERL5LIB
		if [ ! "$PERLPATH" ] ; then
			case "$DSTET_64" in
			[yY]*) PERLPATH=/opt/perl5x/bin ;;
			*) PERLPATH=/usr/bin ;;
			esac
		fi
		PATH=${PERLPATH}:$PATH
		export PATH

		;;
	SunOS-i386)
		if [ ! -d  "$TET_ROOT/../perl/SunOS5.8-i386/lib/nsPerl5.005_03" ] ; then
		    unzip $TET_ROOT/../perl/SunOS5.8-i386/nsperlsolx86.zip -d $TET_ROOT/../perl/SunOS5.8-i386
		else
		    echo "Perl already unzipped"
		fi
		$TET_ROOT/../perl/SunOS5.8-i386/lib/nsPerl5.005_03/install

		LD_LIBRARY_PATH=$LOCAL_PREFIX/lib/perl/arch/auto/Mozilla/LDAP/API:$LOCAL_PREFIX/lib/dirsec:$LOCAL_PREFIX/lib:/usr/lib/dirsec:/usr/lib:$LD_LIBRARY_PATH
		export LD_LIBRARY_PATH
		PERL5LIB=$LOCAL_PREFIX/lib/perl/
		export PERL5LIB
		if [ ! "$PERLPATH" ] ; then
			case "$DSTET_64" in
			[yY]*) PERLPATH=/opt/perl5x/bin ;;
			*) PERLPATH=/usr/bin ;;
			esac
		fi
		PATH=${PERLPATH}:$PATH
		export PATH

		;;
	Windows_NT)
		if [ ! -d  "$TET_ROOT/../perl/winnt4.0/lib/nsPerl5.6.1" ] ; then
		 $TESTING_SHARED/DS/$VER/bin/Windows_NT/unzip $TET_ROOT/../perl/winnt4.0/nsperlwin.zip -d $TET_ROOT/../perl/winnt4.0
		else
			echo "Perl already unzipped"
		fi
		# hack to get the install work on NT
		cworkdir=`pwd`
		cd $TET_ROOT/../perl/winnt4.0/lib/nsPerl5.6.1
		./install.bat
		cd $cworkdir

		;;

	AIX)

		if [ ! -d  "$TET_ROOT/../perl/aix4.3/lib/nsPerl5.005_03" ] ; then
		 unzip $TET_ROOT/../perl/aix4.3/nsperlaix.zip -d $TET_ROOT/../perl/aix4.3
		else
			echo "Perl already unzipped"
		fi
		$TET_ROOT/../perl/aix4.3/lib/nsPerl5.005_03/install

		LD_LIBRARY_PATH=$LOCAL_PREFIX/lib/perl/arch/auto/Mozilla/LDAP/API:$LOCAL_PREFIX/lib/dirsec:$LOCAL_PREFIX/lib:/usr/lib/dirsec:/usr/lib:$LD_LIBRARY_PATH
		export LIBPATH
		PERL5LIB=$LOCAL_PREFIX/lib/perl/
		export PERL5LIB

		;;
	HP-UX)
#		if [ ! -d  "$TET_ROOT/../perl/hpux11.0/lib/nsPerl5.6.1" ] ; then
#		 unzip $TET_ROOT/../perl/hpux11.0/nsperlhp.zip -d $TET_ROOT/../perl/hpux11.0
#		else
#			echo "Perl already unzipped"
#		fi
#
#		$TET_ROOT/../perl/hpux11.0/lib/nsPerl5.6.1/install

	    # In addition to using system perl for most perl functionality from 
	    #    DS 7.2 onwards, we also need to use
	    # 1. perldap from the directory installation.
	    # 2. MIME:Base64 within the test framework, which is the only remaining 
	    #    perl module within TET.
		# 3. use nspr/nss libs from the dirsec lib path

		HP_ARCH=`uname -m`
		case "$DSTET_64" in
		[yY]*) 
			if [ "$HP_ARCH" = "ia64" ]; then	
				LD_LIBRARY_PATH=$LOCAL_PREFIX/lib/perl/arch/auto/Mozilla/LDAP/API:$LOCAL_PREFIX/lib/dirsec/hpux64:$LOCAL_PREFIX/lib/hpux64:$LOCAL_PREFIX/lib/dirsec:$LOCAL_PREFIX/lib:/usr/lib/dirsec/hpux64:/usr/lib/hpux64:/usr/lib/dirsec:/usr/lib:$LD_LIBRARY_PATH
			else
				LD_LIBRARY_PATH=$LOCAL_PREFIX/lib/perl/arch/auto/Mozilla/LDAP/API:$LOCAL_PREFIX/lib/dirsec/pa20_64:$LOCAL_PREFIX/lib/pa20_64:$LOCAL_PREFIX/lib/dirsec:$LOCAL_PREFIX/lib:/usr/lib/dirsec/pa20_64:/usr/lib/pa20_64:/usr/lib/dirsec:/usr/lib:$LD_LIBRARY_PATH
			fi
			;;
		*)
			LD_LIBRARY_PATH=$LOCAL_PREFIX/lib/perl/arch/auto/Mozilla/LDAP/API:$LOCAL_PREFIX/lib/dirsec:$LOCAL_PREFIX/lib:/usr/lib/dirsec:/usr/lib:$LD_LIBRARY_PATH
			;;
		esac
		SHLIB_PATH=$LD_LIBRARY_PATH:$SHLIB_PATH
		export LD_LIBRARY_PATH
		export SHLIB_PATH
		PERL5LIB=$LOCAL_PREFIX/lib/perl/
		export PERL5LIB
		if [ ! "$PERLPATH" ] ; then
			case "$DSTET_64" in
			[yY]*) PERLPATH=/opt/perl_64/bin ;;
			*) PERLPATH=/opt/perl/bin ;;
			esac
		fi
		PATH=${PERLPATH}:$PATH
		export PATH

		;;
	Linux)
#		if [ ! -d  "$TET_ROOT/../perl/linux2.2/lib/nsPerl5.6.1" ] ; then
#		 unzip $TET_ROOT/../perl/linux2.2/nsperllinux.zip -d $TET_ROOT/../perl/linux2.2
#		else
#			echo "Perl already unzipped"
#		fi
#		$TET_ROOT/../perl/linux2.2/lib/nsPerl5.6.1/install

	    # In addition to using system perl for most perl functionality from 
	    #    DS 7.2 onwards, we also need to use
	    # 1. perldap from the directory installation.
	    # 2. MIME:Base64 within the test framework, which is the only remaining 
	    #    perl module within TET.
		# 3. use nspr/nss libs from the dirsec lib path

		case "$DSTET_64" in
		[yY]*)
			LD_LIBRARY_PATH=$LOCAL_PREFIX/lib/perl/arch/auto/Mozilla/LDAP/API:$LOCAL_PREFIX/lib64/dirsec:$LOCAL_PREFIX/lib/dirsec:$LOCAL_PREFIX/lib64:$LOCAL_PREFIX/lib:/usr/lib64/dirsec:/usr/lib/dirsec:/usr/lib:$LD_LIBRARY_PATH
			;;
		*)
			LD_LIBRARY_PATH=$LOCAL_PREFIX/lib/perl/arch/auto/Mozilla/LDAP/API:$LOCAL_PREFIX/lib/dirsec:$LOCAL_PREFIX/lib:/usr/lib/dirsec:/usr/lib:$LD_LIBRARY_PATH
			;;
		esac
		export LD_LIBRARY_PATH
		PERL5LIB=$LOCAL_PREFIX/lib/perl/
		export PERL5LIB

		;;
	*)      
		echo "engage: unknown OS \"`uname -s`\""
		echo "engage: MainOS=$MainOS: unexpected value"
		exit 1
esac

	# Use this environment variable for refresh the value in case it was overridden in the tests
	PERL_LD_LIBRARY_PATH=$LD_LIBRARY_PATH
	export PERL_LD_LIBRARY_PATH

	# if not set, just default to /usr/bin
	if [ ! "$PERLPATH" ] ; then
		PERLPATH=/usr/bin
	fi
}


perl_check()
{
  SetPerlEnv $1
}


####### Report Generation routines ###########################################

mktr()
{
n=$1
p=$2
f=$3
r=$4
if [ "$f" != "" ] || [ "$r" != "" ] ; then
	p=""  # don't show pass % if there is fail or noresult
fi
cat <<EOF | sed 's/td><\/td/td>\&nbsp;<\/td/g'
<tr>
<td><a href="#$n">$n</a></td>
<td>$p</td>
<td>$f</td>
<td>$r</td>
</tr>
EOF
}

mksummary()
{
inf=$1
# create summary report
# parse out result
(
echo "<table BORDER WIDTH=\"100%\" NOSAVE >"
cat <<EOF
<tr>
<td><b>Test Name</b></td>
<td><b>PASS</b></td>
<td><b>FAIL</b></td>
<td><b>NORESULT</b></td>
</tr>
EOF
egrep 'Result  for' $inf | sed 's/\\/\\\\/g' | while read i
do
	n=`echo "$i" | cut -d: -f2 | sed 's/^[ ]*//g'`
	x=`echo "$n" | sed 's:\\\\,:.,:g'`
	p=`grep "^    $x"'.*PASS' $inf | cut -d: -f2`
	b=`grep "^    $x"'.*FAIL' $inf | cut -d: -f2`
	r=`grep "^    $x"'.*NORESULT' $inf | cut -d: -f2`
	mktr "$n" "$p" "$b" "$r"
done
echo "</table>"
)
}

htmlheader()
{
cat <<EOF
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Mozilla/4.61 [en] (X11; U; SunOS 5.6 sun4u) [ Netscape]">
</head>
<body>
<br><tt>
EOF
}

htmltrailer()
{
echo "</tt>"
echo "</body>"
echo "</html>"
}

conv2html()
# usage report outputfile
# convert the email report to html format
{
inf=$1

case `engage_domainname` in 
*mtbrook.bozemanpass.com)
echo "<pre>"
sed 's/^\(#* Result *for .*: *\)\(.*\)$/\1 <a name="\2">\2<\/a>/
        /http:\/\//s/\(http:\/\/fileserver\)\(.*\)$/<a href="\1\2">\2<\/a>/g
        /file:\//s/\(file:\/.*\)$/<a href="\1">\1<\/a>/g
        s/FAIL/<b><font color="#FF0000">FAIL<\/font><\/b>/g
        s/NORESULT/<b><font color="#0000FF">NORESULT<\/font><\/b>/g
        s/PASS/<b><font color="#00FF00">PASS<\/font><\/b>/g
        s/http:\/\/fileserver\/\/fileserver\/shared\/projects\/aol\/docs\//http:\/\/fileserver\/aoldocs\//g
        s/http:\/\/fileserver\/h\/shared\/projects\/aol\/docs\//http:\/\/fileserver\/aoldocs\//g' $inf
echo "</pre>"
;;

*)
# enclose the input file content with <pre> and </pre>
# parse the body
# 1 add named anchors to "Result" lines
# 2 add link reference for all http link
# 3 make FAIL red
# 4 make NORESULT blue
# 5 make PASS green
echo "<pre>"
sed 's/^\(#* Result *for .*: *\)\(.*\)$/\1 <a name="\2">\2<\/a>/
	 /http:\/\//s/\(http:\/\/works4you.sfbay.redhat.com\)\(.*\)$/<a href="\1\2">\2<\/a>/g
	 /file:\//s/\(file:\/.*\)$/<a href="\1">\1<\/a>/g
	 s/FAIL/<b><font color="#FF0000">FAIL<\/font><\/b>/g
	 s/NORESULT/<b><font color="#0000FF">NORESULT<\/font><\/b>/g
	 s/PASS/<b><font color="#00FF00">PASS<\/font><\/b>/g' $inf
echo "</pre>"
esac

}


engage_domainname()
{
	nslookup `hostname` 2>/dev/null | awk '/^Name:/ { dnm=$2 } END {print dnm}'|cut -d. -f2-
}

EngageTimer()
# args : pid timeout1 timeout2
# wait up to $timeout1 seconds before sending kill to $pid
# then wait $timeout2 seconds before sending kill -9 to $pid
# if $pid exit before $timeout1, no action will be perform
# $timeout2 should be a small number (ie < 120 seconds)
# Ex : 
#	YourFunction &
#	EngageTimer $! 60 2
{
pid=$1
timeout1=$2
timeout2=$3

stime=`date`
# run in a loop and check process every 10 secs 
while [ $timeout1 -gt 0 ]
do
    sleep 10
	# $(($timeout1-10))
    timeout1=`expr $timeout1 - 10`
    kill -0 $pid > /dev/null 2>&1 # see if process is still alive
    if [ $? -ne 0 ] ; then
        return 0    # process exited, return with no action
    fi
done
echo "process started at $stime"
echo "current time is `date`"
echo "testsuite was still running after $2 seconds. It has been killed"
kill $pid    # send normal termination first
sleep $timeout2
kill -0 $pid > /dev/null 2>&1
if [ $? -eq 0 ]; then # process still running
	echo "kill -9 send"
	kill -9 $pid > /dev/null 2>&1   # sure kill
fi
return 1
}
######################################################################
# stop watch function
######################################################################
EngageStopwatch_stime=""
EngageStopwatch_etime=""
EngageStopwatch()
# arg : [ start | stop | nubmer in second ]
# example :
# 	EngageStopwatch start
# 	sleep 67
# 	es=`EngageStopwatch stop`	# return number of elapse time in second
#	EngageStopwatch $es			# return elapse time in H:M:S - 0:1:7
# function does take into accound of start and stop in different day but not
# different year.
{
case $1 in
	"start")
		EngageStopwatch_stime=`date '+%j:%T'` # %j to take into accound of run over a new day
		;;
	"stop")
		EngageStopwatch_etime=`date '+%j:%T'`
		OIFS=$IFS
		IFS=':'
			# use awk to convert to number ex : 08 to 8
			set - $EngageStopwatch_stime
			sd=`echo $1 | awk '{print 0+$1}'`;
			sh=`echo $2 | awk '{print 0+$1}'`;
			sm=`echo $3 | awk '{print 0+$1}'`;
			ss=`echo $4 | awk '{print 0+$1}'`;
			set - $EngageStopwatch_etime
			ed=`echo $1 | awk '{print 0+$1}'`;
			eh=`echo $2 | awk '{print 0+$1}'`;
			em=`echo $3 | awk '{print 0+$1}'`;
			es=`echo $4 | awk '{print 0+$1}'`;
		IFS=$OIFS

		# s=$(($sd*86400+$sh*3600+$sm*60+$ss))
		s=`expr $sd \* 86400 + $sh \* 3600 + $sm \* 60 + $ss`
		# e=$(($ed*86400+$eh*3600+$em*60+$es))
		e=`expr $ed \* 86400 + $eh \* 3600 + $em \* 60 + $es`
		# es=$(($e-$s))
		es=`expr $e - $s`
		echo $es # elapse time in seconds
		;;
	*) # given number of seconds, return elapse time in the form of h:m:s
		#echo $(($1/3600)):$(($1%3600/60)):$(($1%60))
		echo `expr $1 / 3600`:`expr $1 % 3600 / 60`:`expr $1 % 60`
		;;
esac
}


# args: orig-pid
# echos back: the true pid (found by looking for a child process on Windows)
find_pid_of_child()
{
	orig_pid=$1

	if [ "$MainOS" = "Windows_NT" ] ; then
		#
		# On Windows, processes that are started by ksh in the background return
		# the PID of a parent ksh process to the invoking shell (in $!) instead 
		# of the PID of the actual process that was started. Use ps to uncover
		# the truth. The pipeline below assumes the parent process has exactly
		# one child.
		child_pid=`ps -ef | awk '{print $3 " " $2}' | grep "^$orig_pid" | awk '{print $2}'`
	else
		child_pid=$orig_pid;
	fi
	echo $child_pid;
	return $child_pid;
}
# End of file
